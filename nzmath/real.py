from __future__ import division, generators
import operator
import math
import itertools
from prime import vp as _vp
import rational

"""

The module `real' provides arbitrary precision real numbers and their
utilities.  The functions provided are corresponding to the `math'
standard module.

"""

class RealField:
    """

    RealField is a class of the field of real numbers.
    The class has the single instance 'theRealField'.

    """

    def __contains__(self, element):
        reduced = +element
        if reduced in rational.theRationalField:
            return True
        if isinstance(reduced, float):
            return True
        return False  ## How to know a number is real ?

class RelativeError:
    def __init__(self, comparity, numerator, denominator=1):
        self.comparity = comparity
        self.relativeerrorrange = rational.Rational(numerator, denominator)

    def absoluteerror(self, numerator, denominator=1):
        r = rational.Rational(numerator,denominator)*self.relativeerrorrange
        return AbsoluteError(self.comparity, r.numerator, r.denominator)

    def islarge(self):
        if (self.comparity > 0) :
            return True
        elif (self.comparity < 0) :
            return False
        else:
            return None

    def issmall(self):
        if (self.comparity < 0) :
            return True
        elif (self.comparity > 0) :
            return False
        else:
            return None

    def nearlyEqual(self, x, y):
        """

        Compare two real numbers with respect to this error, whether
        they are within the given range or not.  If self.issmall(),
        the first argument must be smaller than the second.  If
        self.islarge(), the first argument must be bigger than the
        second.

        """
        return self.absoluteerror(x).nearlyEqual(x, y)

    def __lt__(self, other):
        if not isinstance(other, RelativeError):
            return False
        if self.relativeerrorrange < other.relativeerrorrange and (self.comparity == other.comparity or self.comparity != 0 and other.comparity == 0):
            return True
        return False

class AbsoluteError:
    def __init__(self, comparity, numerator, denominator=1):
        self.comparity = comparity
        self.absoluteerrorrange = abs(rational.Rational(numerator, denominator))
        
    def islarge(self):
        if (self.comparity > 0) :
            return True
        elif (self.comparity < 0) :
            return False
        else:
            return None

    def issmall(self):
        if (self.comparity < 0) :
            return True
        elif (self.comparity > 0) :
            return False
        else:
            return None

    def nearlyEqual(self, x, y):
        """

        Compare two real numbers with respect to this error, whether
        they are within the given range or not.  If self.issmall(),
        the first argument must be smaller than the second.  If
        self.islarge(), the first argument must be bigger than the
        second.

        """
        if self.issmall():
            return 0 <= y - x < self.absoluteerrorrange
        elif self.islarge():
            return 0 <= x - y < self.absoluteerrorrange
        else:
            return abs(x-y) < self.absoluteerrorrange

    def __lt__(self, other):
        if not isinstance(other, AbsoluteError):
            return False
        if self.absoluteerrorrange < other.absoluteerrorrange and (self.comparity == other.comparity or self.comparity != 0 and other.comparity == 0):
            return True
        return False

theRealField = RealField()

### function rewrite
class ExponentialPowerSeries:
    """

    A class for exponential power serieses, whose n-th term has form:
      a_n * x ** n / n!
    

    """
    def __init__(self, iterator):
        """

        ExponentialPowerSeries(iterator) constructs an exponential
        power series with coefficient generated by the given iterator,
        which can be an infinite iterator.

        """
        self.iterator = iterator
        self.dirtyflag = False

    def terms(self, x):
        """

        Generator of terms of series with assigned x value.

        """
        if x == 0:
            yield self.iterator.next()
        else:
            f = 1
            i = 0
            y = rational.Integer(1)
            for an in self.iterator:
                yield an * y / f
                y *= x
                i += 1
                f *= i

    def __call__(self, x, maxerror):
        if self.dirtyflag:
            raise Exception, 'ExponentialPowerSeries cannot be called more than once'
        self.dirtyflag = True
        value = oldvalue = 0
        for t in self.terms(x):
            if not t:
                continue
            value += t
            if maxerror.nearlyEqual(value, oldvalue):
                return value
            oldvalue = +value

defaultError = RelativeError(0, 1, 2 ** 53)

def exp(x, err=defaultError):
    series = ExponentialPowerSeries(itertools.cycle((rational.Integer(1),)))
    reduced = rational.Rational(x)
    if reduced < 0:
        reverse = -1
        reduced = -reduced
    else:
        reverse = 1
    i = 0
    while reduced >= 2:
        reduced /= 2
        i += 1
    if reduced == 0:
        retval = rational.Integer(1)
    else:
        retval = series(reduced, err)
    if i > 0:
        retval **= 2 ** i
    if reverse < 0:
        retval = 1 / retval
    return retval

def sqrt(x, err=defaultError):
    """

    sqrt(x [,err]) returns the positive square root of real number x.

    """
    import prime
    reduced = rational.Rational(x)
    if reduced.numerator < 0:
        raise ValueError, "negative number is passed to sqrt"
    if reduced.numerator == 0:
        return rational.Integer(0)
    rt = rational.Rational(prime.sqrt(reduced.numerator)+1, prime.sqrt(reduced.denominator))
    newrt = (rt + reduced / rt) / 2
    while not err.nearlyEqual(rt, newrt):
        rt = newrt
        newrt = (rt + reduced / rt) / 2
    return newrt

def log(x, err=defaultError):
    """

    Return logarithm of a positive number x.

    """
    if isinstance(x, complex):
        raise TypeError, "real.log is not for complex numbers."
    if x < 0:
        raise ValueError, "log is not defined for %s" % str(x)
    rx = rational.Rational(x)
    upper = rational.Rational(4, 3)
    lower = rational.Rational(2, 3)
    shift = 0
    while rx > upper:
        rx /= 2
        shift += 1
    while rx < lower:
        rx *= 2
        shift -= 1
    if rx == 1:
        return shift * _log2(err)
    value = oldvalue = 0
    for term in log1piter(rx - 1):
        value += term
        if err.nearlyEqual(value, oldvalue):
            break
        oldvalue = +value
    if shift != 0:
        return value + shift * _log2(err)
    return value

def log1piter(xx):
    " iterator for log(1+x)."
    d = 1
    positive = True
    t = rational.Rational(xx)
    yield t
    while True:
        d += 1
        positive = not positive
        t *= xx
        if positive:
            yield (t / d)
        else:
            yield (-t / d)

def _log2(err=defaultError):
    """

    _log2([err]) returns the logarithm of 2.

    """
    def log_iter_half():
        """

        log_iter_half generates the terms of Taylor expansion series
        of logarithm of 1/2.

        """
        d = 1
        t = rational.Rational(1,2)
        yield t
        while True:
            t /= 2
            d += 1
            yield (t / d)

    value = oldvalue = 0
    for term in log_iter_half():
        value += term
        if err.nearlyEqual(value, oldvalue):
            return value
        oldvalue = +value

def piGaussLegendre(err=defaultError):
    """

    piGaussLegendre computes pi by Gauss-Legendre algorithm.

    """
    if isinstance(err, RelativeError):
        _err = err.absoluteerror(3.1415)
    else:
        _err = err
    werr = AbsoluteError(0, _err.absoluteerrorrange ** 2)
    maxdenom = int(1 / werr.absoluteerrorrange) * 2
    a = rational.Integer(1)
    b = (1 / sqrt(rational.Rational(2), werr)).trim(maxdenom)
    t = rational.Rational(1, 4)
    x = 1
    while not err.nearlyEqual(a, b):
        a, b, c = (a + b) / 2, sqrt(a * b, werr).trim(maxdenom), (b - a) ** 2 / 4
        t -= x * c
        x *= 2
    return (a + b) ** 2 / (t * 4)

def floor(x):
    """

    floor(x) returns the integer; if x is an integer then x itself,
    otherwise the biggest integer less than x.

    """
    rx = rational.Rational(x)
    if rx.denominator == 1:
        return rational.Integer(rx.numerator)
    return rx.numerator // rx.denominator

def ceil(x):
    """

    ceil(x) returns the integer; if x is an integer then x itself,
    otherwise the smallest integer greater than x.

    """
    rx = rational.Rational(x)
    if rx.denominator == 1:
        return rational.Integer(rx.numerator)
    return rx.numerator // rx.denominator + 1

def tranc(x):
    """

    tranc(x) returns the integer; if x is an integer then x itself,
    otherwise the nearest integer to x.  If x has the fraction part
    1/2, then bigger one will be chosen.

    """
    rx = rational.Rational(x)
    if rx.denominator == 1:
        return rational.Integer(rx.numerator)
    return floor(x + rational.Rational(1,2))

def sin(x, err=defaultError):
    """

    sin(x [,err]) returns the sine of x.

    """
    series = ExponentialPowerSeries(itertools.cycle((0,rational.Integer(1),0,rational.Integer(-1))))
    rx = rational.Rational(x)
    sign = rational.Rational(1)
    # sin(-x) = -sin(x)
    if rx < 0:
        sign = -sign
        rx = -rx
    # sin(x + 2 * pi) = sin(x)
    if rx > 2 * pi(err):
        rx -= floor(rx / (pi(err) * 2)) * (pi(err) * 2)
    # sin(x + pi) = -sin(x)
    if rx > pi(err):
        rx -= pi(err)
        sign = -sign
    # sin(x) = sin(pi - x)
    if rx > pi(err) / 2:
        rx = pi(err) - rx
    # sin(0) = 0 is a special case which must not be computed with series.
    if rx == 0:
        return 0
    retval = series(rx, err) * sign
    if retval > 1:
        retval = rational.Integer(1)
    elif retval < -1:
        retval = rational.Integer(-1)
    return retval

def cos(x, err=defaultError):
    """

    cos(x [,err]) returns the cosine of x.

    """
    series = ExponentialPowerSeries(itertools.cycle((rational.Integer(1),0,rational.Integer(-1), 0)))
    rx = rational.Rational(x)
    sign = rational.Rational(1)
    # cos(-x) = cos(x)
    if rx < 0:
        rx = -rx
    # cos(x + 2 * pi) = cos(x)
    if rx > 2 * pi(err):
        rx -= floor(rx / (pi(err) * 2)) * (pi(err) * 2)
    # cos(x + pi) = -cos(x)
    if rx > pi(err):
        rx -= pi(err)
        sign = -sign
    # cos(x) = -cos(pi - x)
    if rx > pi(err) / 2:
        rx = pi(err) - rx
        sign = -sign
    # cos(0) = 1 is a special case which must not be computed with series.
    if rx == 0:
        return sign
    retval = series(rx, err) * sign
    if retval > 1:
        retval = rational.Integer(1)
    elif retval < -1:
        retval = rational.Integer(-1)
    return retval

def tan(x, err=defaultError):
    """

    tan(x [,err]) returns the tangent of x.

    """
    return sin(x, err) / cos(x, err)

def sinh(x, err=defaultError):
    """

    sinh(x [,err]) returns the hyperbolic sine of x.

    """
    series = ExponentialPowerSeries(itertools.cycle((0,rational.Integer(1),)))
    rx = rational.Rational(x)
    if rx == 0:
        return rational.Integer(0)
    return series(rx, err)

def cosh(x, err=defaultError):
    """

    cosh(x [,err]) returns the hyperbolic cosine of x.

    """
    series = ExponentialPowerSeries(itertools.cycle((rational.Integer(1),0,)))
    rx = rational.Rational(x)
    if rx == 0:
        return rational.Integer(1)
    return series(rx, err)

def tanh(x, err=defaultError):
    """

    tanh(x [,err]) returns the hyperbolic tangent of x.

    """
    rx = rational.Rational(x)
    return sinh(rx, err) / cosh(rx, err)

def acos(x, err= defaultError):
    """

    acos(x [,err]) returns arc cosine of x.

    """
    if x > 1 or x < -1:
        raise ValueError, "%s is not in the range [-1, 1]." % str(x)
    if x == 0:
        return pi(err) / 2
    rx = rational.Rational(x)
    y = sqrt(1 - rx ** 2)
    if rx > 0:
        return asin(y, err)
    else:
        return pi(err) + asin(-y, err)

def asin(x, err=defaultError):
    """

    asin(x [,err]) returns arc sine of x.

    """
    if x > 1 or x < -1:
        raise ValueError, "%s is not in the range [-1, 1]." % str(x)
    if x < 0:
        return -asin(-x)
    u = sqrt(rational.Rational(1, 2))
    if x > u:
        return pi(err) / 2 - asin(sqrt(1 - x**2))
    if x == 0:
        return rational.Integer(0)
    y = rational.Rational(x)
    y2 = y ** 2
    i = 2
    retval = y
    term = rational.Rational(y)
    oldvalue = 0
    while err.nearlyEquals(retval, oldvalue):
        oldvalue = +retval
        term *= y2 * (i-1) ** 2 / (i*(i+1))
        i += 2
        retval += term
    return retval

def atan(x, err=defaultError):
    """

    atan(x [,err]) returns arc tangent of x.

    """
    # atan(x) = -atan(-x)
    if x < 0:
        return -atan(-x, err)
    # atan(x) = pi/2 - atan(1/x)
    elif x > 1:
        return pi(err) / 2 - atan(1 / x, err)
    elif x == 1:
        return pi(err) / 4
    elif x == 0:
        return rational.Integer(0)
    y = rational.Rational(x)
    y2 = y ** 2
    retval = y
    oldvalue = 0
    term = rational.Rational(x)
    i = 1
    while err.nearlyEquals(retval, oldvalue):
        oldvalue = +retval
        i += 2
        term *= -y2 * (i-2) / i
        retval += term
    return retval

def atan2(y, x, err=defaultError):
    """

    atan2(x, y [,err]) returns the arc tangent of y/x.
    Unlike atan(y/x), the signs of both x and y are considered.

    It is unrecomended to obtain the value of pi with atan2(0,1).

    """
    if x > 0 and y > 0:
        return atan(x/y)
    elif x > 0 and y < 0:
        return pi(err) * 2 + atan(x/y)
    elif x < 0:
        return pi(err) + atan(x/y)
    elif x == 0 and y > 0:
        return pi(err) / 2
    elif x == 0 and y < 0:
        return -pi(err) / 2
    return rational.Integer(0)

def hypot(x, y, err=defaultError):
    """

    hypot(x, y [,err]) returns sqrt(x**2 + y**2).

    """
    return sqrt(x**2 + y**2, err)

def EulerTransform(iterator):
    """

    Return an iterator which yields terms of Euler transform of the
    given iterator.

    """
    stock = []
    b = rational.Rational(1,2)
    l = -1
    for term in iterator:
        stock.append(term)
        for i in xrange(l, -1, -1):
            stock[i] += stock[i+1]
        yield b * stock[0]
        b /= 2
        l += 1

class Constant:
    """

    Constant provides constant-like behavior for Float calculation
    context.  It caches the constant value and re-computes for more
    precision by request.

    example:
    >>> pi = Constant(piGaussLegendre)
    >>> print pi
    3.14159265358979
    >>> pi + 1
    4.14159265358979
    >>> pi(RelativeError(0,1,2**100)) # for 100 bit precision
    3.1415926535897932384626433832795

    """
    def __init__(self, getValue, err=defaultError):
        """

        The first argument must be a function which computes the
        constant with an argument specifies error.
        The second argument can be used to set the default error.

        """
        self.getValue = getValue
        self.err = err
        self.cache = self.getValue(self.err)

    def __call__(self, err):
        """

        Return the value at least as accurate as the given error.

        """
        if self.err < err:
            self.cache = self.getValue(err)
            self.err = err
        return self.cache

    # delegations
    def __add__(self, other):
        return self.cache.__add__(other)

    def __radd__(self, other):
        return self.cache.__radd__(other)

    def __sub__(self, other):
        return self.cache.__sub__(other)

    def __rsub__(self, other):
        return self.cache.__rsub__(other)

    def __mul__(self, other):
        return self.cache.__mul__.other

    def __rmul__(self, other):
        return self.cache.__rmul__(other)

    def __div__(self, other):
        return self.cache.__div__(other)

    def __rdiv__(self, other):
        return self.cache.__rdiv__(other)

    def __truediv__(self, other):
        return self.cache.__truediv__(other)

    def __rtruediv__(self, other):
        return self.cache.__rtruediv__(other)

    def __divmod__(self, other):
        return self.cache.__divmod__(other)

    def __rdivmod__(self, other):
        return self.cache.__rdivmod__(other)

    def __mod__(self, other):
        return self.cache.__mod__(other)

    def __rmod__(self, other):
        return self.cache.__rmod__(other)

    def __pos__(self):
        return self.cache.__pos__()

    def __neg__(self):
        return self.cache.__neg__()

    def __abs__(self):
        return self.cache.__neg__()

    def toRational(self):
        return +self.cache

    def inverse(self):
        return self.cache.__rdiv__(rational.Integer(1))

    def __pow__(self, other, dummy=None):
        return self.cache.__pow__(other)

    def __gt__(self, other):
        return self.cache.__gt__(other)

    def __ge__(self, other):
        return self.cache.__ge__(other)

    def __eq__(self, other):
        return self.cache.__eq__(other)

    def __ne__(self, other):
        return self.cache.__ne__(other)

    def __le__(self, other):
        return self.cache.__le__(other)

    def __lt__(self, other):
        return self.cache.__lt__(other)

    def __repr__(self):
        return repr(self.cache)

    def __str__(self):
        return str(self.cache)

    def __getattr__(self, name):
        try:
            return getattr(self.cache, name)
        except:
            raise

pi = Constant(piGaussLegendre)
e = Constant(lambda err: exp(1, err))
Log2 = Constant(lambda err: _log2(err))
