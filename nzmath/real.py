from __future__ import division, generators
import operator
import math
import itertools
from prime import vp as _vp
import rational

"""

The module `real' provides arbitrary precision real numbers and their
utilities.  The functions provided are corresponding to the `math'
standard module.

"""

class RealField:
    """

    RealField is a class of the field of real numbers.
    The class has the single instance 'theRealField'.

    """

    def __contains__(self, element):
        reduced = +element
        if reduced in rational.theRationalField:
            return True
        if isinstance(reduced, float):
            return True
        return False  ## How to know a number is real ?

class RelativeError:
    def __init__(self, comparity, numerator, denominator=1):
        self.comparity = comparity
        self.relativeerrorrange = rational.Rational(numerator, denominator)

    def absoluteerror(self, numerator, denominator=1):
        r = rational.Rational(numerator,denominator)*self.relativeerrorrange
        return AbsoluteError(self.comparity, r.numerator, r.denominator)

    def islarge(self):
        if (self.comparity > 0) :
            return True
        elif (self.comparity < 0) :
            return False
        else:
            return None

    def issmall(self):
        if (self.comparity < 0) :
            return True
        elif (self.comparity > 0) :
            return False
        else:
            return None

    def nearlyEqual(self, x, y):
        """

        Compare two real numbers with respect to this error, whether
        they are within the given range or not.  If self.issmall(),
        the first argument must be smaller than the second.  If
        self.islarge(), the first argument must be bigger than the
        second.

        """
        return self.absoluteerror(x).nearlyEqual(x, y)

    def __eq__(self, other):
        if not isinstance(other, RelativeError):
            return False
        if self.relativeerrorrange == other.relativeerrorrange and (self.comparity == other.comparity or self.comparity * other.comparity == 0):
            return True
        return False

    def __lt__(self, other):
        if not isinstance(other, RelativeError):
            return False
        if self.relativeerrorrange < other.relativeerrorrange and (self.comparity == other.comparity or self.comparity != 0 and other.comparity == 0):
            return True
        return False

    def __le__(self, other):
        if not isinstance(other, RelativeError):
            return False
        if self.relativeerrorrange <= other.relativeerrorrange and (self.comparity == other.comparity or self.comparity * other.comparity == 0):
            return True
        return False

    def __div__(self, other):
        return self.__class__(self.comparity, self.relativeerrorrange, other)

    __truediv__ = __div__

class AbsoluteError:
    def __init__(self, comparity, numerator, denominator=1):
        self.comparity = comparity
        self.absoluteerrorrange = abs(rational.Rational(numerator, denominator))
        
    def islarge(self):
        if (self.comparity > 0) :
            return True
        elif (self.comparity < 0) :
            return False
        else:
            return None

    def issmall(self):
        if (self.comparity < 0) :
            return True
        elif (self.comparity > 0) :
            return False
        else:
            return None

    def nearlyEqual(self, x, y):
        """

        Compare two real numbers with respect to this error, whether
        they are within the given range or not.  If self.issmall(),
        the first argument must be smaller than the second.  If
        self.islarge(), the first argument must be bigger than the
        second.

        """
        if self.issmall():
            return 0 <= y - x < self.absoluteerrorrange
        elif self.islarge():
            return 0 <= x - y < self.absoluteerrorrange
        else:
            return abs(x-y) < self.absoluteerrorrange

    def __lt__(self, other):
        if not isinstance(other, AbsoluteError):
            return False
        if self.absoluteerrorrange < other.absoluteerrorrange and (self.comparity == other.comparity or self.comparity != 0 and other.comparity == 0):
            return True
        return False

    def __div__(self, other):
        return self.__class__(self.comparity, self.absoluteerrorrange, other)

    __truediv__ = __div__

### function rewrite
class ExponentialPowerSeries:
    """

    A class for exponential power serieses, whose n-th term has form:
      a_n * x ** n / n!
    

    """
    def __init__(self, iterator):
        """

        ExponentialPowerSeries(iterator) constructs an exponential
        power series with coefficient generated by the given iterator,
        which can be an infinite iterator.

        """
        self.iterator = iterator
        self.dirtyflag = False

    def terms(self, x):
        """

        Generator of terms of series with assigned x value.

        """
        if x == 0:
            yield rational.Rational(self.iterator.next())
        else:
            i = 0
            r = rational.Rational(1,1)
            for an in self.iterator:
                yield an * r
                i += 1
                r *= rational.Rational(x, i)

    def __call__(self, x, maxerror):
        if self.dirtyflag:
            raise Exception, 'ExponentialPowerSeries cannot be called more than once'
        self.dirtyflag = True
        value, oldvalue = rational.Rational(0), rational.Rational(0)
        if isinstance(maxerror, RelativeError):
            maxDenom = minNumer = 0
            for t in self.terms(x):
                if not t:
                    continue
                if not maxDenom:
                    value += t
                    maxDenom = (maxerror.relativeerrorrange.denominator * value.denominator) ** 2
                elif value.denominator < maxDenom:
                    value += t
                    if maxerror.nearlyEqual(value, oldvalue):
                        break
                else:
                    if not minNumer:
                        minNumer = maxerror.relativeerrorrange.numerator * abs(value.numerator) // maxerror.relativeerrorrange.denominator
                    approx = t.numerator * value.denominator // t.denominator
                    value.numerator += approx
                    if abs(approx) < minNumer:
                        break
                oldvalue = +value
        else:
            maxDenom = minNumer = 0
            for t in self.terms(x):
                if not t:
                    continue
                if not maxDenom:
                    value += t
                    maxDenom = (maxerror.absoluteerrorrange.denominator * value.denominator) ** 2
                elif value.denominator < maxDenom:
                    value += t
                else:
                    if not minNumer:
                        minNumer = maxerror.absoluteerrorrange.numerator * value.numerator // maxerror.absoluteerrorrange.denominator
                    approx = t.numerator * value.denominator // t.denominator
                    value.numerator += approx
                    if abs(approx) < minNumer:
                        break
                oldvalue = +value
        return value
            

defaultError = RelativeError(0, 1, 2 ** 53)

def exp(x, err=defaultError):
    if err <= defaultError:
        reduced = rational.Rational(x)
        if reduced < 0:
            reverse = -1
            reduced = -reduced
        else:
            reverse = 1
        i = 0
        while reduced >= 2:
            reduced /= 2
            i += 1
        if reduced == 0:
            retval = rational.Integer(1)
        else:
            series = ExponentialPowerSeries(itertools.cycle((rational.Integer(1),)))
            retval = series(reduced, err)
        if i > 0:
            retval **= 2 ** i
        if reverse < 0:
            retval = 1 / retval
    else:
        retval = rational.Rational(math.exp(x))
    return retval

def sqrt(x, err=defaultError):
    """

    sqrt(x [,err]) returns the positive square root of real number x.

    """
    import prime
    reduced = rational.Rational(x)
    if reduced.numerator < 0:
        raise ValueError, "negative number is passed to sqrt"
    if reduced.numerator == 0:
        return rational.Integer(0)
    if err <= defaultError:
        rt = rational.Rational(prime.sqrt(reduced.denominator * reduced.numerator)+1, reduced.denominator)
        newrt = (rt + reduced / rt) / 2
        while not err.nearlyEqual(rt, newrt):
            rt = newrt
            newrt = (rt + reduced / rt) / 2
    else:
        newrt = rational.Rational(math.sqrt(x))
    return newrt

def log(x, err=defaultError):
    """

    Return logarithm of a positive number x.

    """
    if isinstance(x, complex):
        raise TypeError, "real.log is not for complex numbers."
    if x < 0:
        raise ValueError, "log is not defined for %s" % str(x)
    if err <= defaultError:
        rx = rational.Rational(x)
        upper = rational.Rational(4, 3)
        lower = rational.Rational(2, 3)
        shift = 0
        while rx > upper:
            rx /= 2
            shift += 1
        while rx < lower:
            rx *= 2
            shift -= 1
        if rx == 1:
            return shift * _log2(err)
        value = oldvalue = 0
        for term in log1piter(rx - 1):
            value += term
            if err.nearlyEqual(value, oldvalue):
                break
            oldvalue = +value
        if shift != 0:
            return value + shift * _log2(err)
    else:
        value = rational.Rational(math.log(x))
    return value

def log1piter(xx):
    " iterator for log(1+x)."
    d = 1
    positive = True
    t = rational.Rational(xx)
    yield t
    while True:
        d += 1
        positive = not positive
        t *= xx
        if positive:
            yield (t / d)
        else:
            yield (-t / d)

def _log2(err=defaultError):
    """

    _log2([err]) returns the logarithm of 2.

    """
    def log_iter_half():
        """

        log_iter_half generates the terms of Taylor expansion series
        of logarithm of 1/2.

        """
        d = 1
        t = rational.Rational(1,2)
        yield t
        while True:
            t /= 2
            d += 1
            yield (t / d)

    value = oldvalue = 0
    for term in log_iter_half():
        value += term
        if err.nearlyEqual(value, oldvalue):
            return value
        oldvalue = +value

def piGaussLegendre(err=defaultError):
    """

    piGaussLegendre computes pi by Gauss-Legendre algorithm.

    """
    if isinstance(err, RelativeError):
        _err = err.absoluteerror(3.1415)
    else:
        _err = err
    werr = AbsoluteError(0, _err.absoluteerrorrange ** 2)
    maxdenom = int(1 / werr.absoluteerrorrange) * 2
    a = rational.Integer(1)
    b = (1 / sqrt(rational.Rational(2), werr)).trim(maxdenom)
    t = rational.Rational(1, 4)
    x = 1
    while not err.nearlyEqual(a, b):
        a, b, c = (a + b) / 2, sqrt(a * b, werr).trim(maxdenom), (b - a) ** 2 / 4
        t -= x * c
        x *= 2
    return (a + b) ** 2 / (t * 4)

def floor(x):
    """

    floor(x) returns the integer; if x is an integer then x itself,
    otherwise the biggest integer less than x.

    """
    rx = rational.Rational(x)
    if rx.denominator == 1:
        return rational.Integer(rx.numerator)
    return rx.numerator // rx.denominator

def ceil(x):
    """

    ceil(x) returns the integer; if x is an integer then x itself,
    otherwise the smallest integer greater than x.

    """
    rx = rational.Rational(x)
    if rx.denominator == 1:
        return rational.Integer(rx.numerator)
    return rx.numerator // rx.denominator + 1

def tranc(x):
    """

    tranc(x) returns the integer; if x is an integer then x itself,
    otherwise the nearest integer to x.  If x has the fraction part
    1/2, then bigger one will be chosen.

    """
    rx = rational.Rational(x)
    if rx.denominator == 1:
        return rational.Integer(rx.numerator)
    return floor(x + rational.Rational(1,2))

def sin(x, err=defaultError):
    """

    sin(x [,err]) returns the sine of x.

    """
    if not isinstance(err, defaultError.__class__) or err <= defaultError:
        rx = rational.Rational(x)
        sign = rational.Rational(1)
        # sin(-x) = -sin(x)
        if rx < 0:
            sign = -sign
            rx = -rx
        # sin(x + 2 * pi) = sin(x)
        if rx >= 2 * pi:
            rx -= floor(rx / (pi * 2)) * (pi * 2)
        # sin(x + pi) = -sin(x)
        if rx >= pi:
            rx -= pi
            sign = -sign
        # sin(x) = sin(pi - x)
        if rx > pi / 2:
            rx = pi - rx
        # sin(0) = 0 is a special case which must not be computed with series.
        if rx == 0:
            return rational.Rational(0)
        # sin(x) = cos(pi/2 - x) (pi/2 >= x > 4/pi)
        if rx > pi / 4:
            if rx == pi / 3:
                retval = sqrt(3) / 2
            else:
                retval = _cosTaylor(pi / 2 - rx, err)
        elif rx == pi / 4:
            retval = 1 / sqrt(2)
        elif rx == pi / 6:
            retval = rational.Rational(1, 2)
        else:
            retval = _sinTaylor(rx, err)
        if retval > 1:
            retval = rational.Integer(1)
        retval *= sign
    else:
        retval = rational.Rational(math.sin(x))
    return retval

def _sinTaylor(x, err=defaultError):
    """

    _sinTaylor(x [,err]) returns the sine of x by Taylor expansion.
    It is recommended to use only for 0 <= x <= pi / 4.

    """
    rx = rational.Rational(x)
    sinSeries = ExponentialPowerSeries(itertools.cycle((0,rational.Integer(1),0,rational.Integer(-1))))
    return sinSeries(rx, err)

def cos(x, err=defaultError):
    """

    cos(x [,err]) returns the cosine of x.

    """
    if err <= defaultError:
        rx = rational.Rational(x)
        sign = rational.Rational(1)
        # cos(-x) = cos(x)
        if rx < 0:
            rx = -rx
        # cos(x + 2 * pi) = cos(x)
        if rx > 2 * pi:
            rx -= floor(rx / (pi * 2)) * (pi * 2)
        # cos(x + pi) = -cos(x)
        if rx > pi:
            rx -= pi
            sign = -sign
        # cos(x) = -cos(pi - x)
        if rx > pi / 2:
            rx = pi - rx
            sign = -sign
        # cos(x) = sin(pi/2 - x) (pi/2 >= x > 4/pi)
        if rx > pi / 4:
            if rx == pi / 3:
                retval = rational.Rational(1,2)
            else:
                retval = _sinTaylor(pi / 2 - rx, err)
        elif rx == pi / 4:
            retval = 1 / sqrt(2)
        elif rx == pi / 6:
            retval = sqrt(3) / 2
        else:
            retval = _cosTaylor(rx, err)
        if retval > 1:
            retval = rational.Integer(1)
        retval *= sign
    else:
        retval = rational.Rational(math.cos(x))
    return retval

def _cosTaylor(x, err=defaultError):
    """

    _cosTaylor(x [,err]) returns the cosine of x by Taylor series.
    It is recomended to use only for 0 <= x <= pi / 4.

    """
    cosSeries = ExponentialPowerSeries(itertools.cycle((rational.Integer(1),0,rational.Integer(-1), 0)))
    rx = rational.Rational(x)
    return cosSeries(rx, err)

def tan(x, err=defaultError):
    """

    tan(x [,err]) returns the tangent of x.

    """
    return sin(x, err) / cos(x, err)

def sinh(x, err=defaultError):
    """

    sinh(x [,err]) returns the hyperbolic sine of x.

    """
    if not isinstance(err, defaultError.__class__) or err <= defaultError:
        series = ExponentialPowerSeries(itertools.cycle((0,rational.Integer(1),)))
        rx = rational.Rational(x)
        if rx == 0:
            return rational.Rational(0)
        return series(rx, err)
    else:
        return rational.Rational(math.sinh(x))

def cosh(x, err=defaultError):
    """

    cosh(x [,err]) returns the hyperbolic cosine of x.

    """
    if err <= defaultError:
        series = ExponentialPowerSeries(itertools.cycle((rational.Integer(1),0,)))
        rx = rational.Rational(x)
        if rx == 0:
            return rational.Integer(1)
        return series(rx, err)
    else:
        return rational.Rational(math.cosh(x))

def tanh(x, err=defaultError):
    """

    tanh(x [,err]) returns the hyperbolic tangent of x.

    """
    rx = rational.Rational(x)
    return sinh(rx, err) / cosh(rx, err)

def acos(x, err= defaultError):
    """

    acos(x [,err]) returns arc cosine of x.

    """
    if x > 1 or x < -1:
        raise ValueError, "%s is not in the range [-1, 1]." % str(x)
    if x == 0:
        return pi(err) / 2
    if err <= defaultError:
        rx = rational.Rational(x)
        y = sqrt(1 - rx ** 2)
        if rx > 0:
            return asin(y, err)
        else:
            return pi(err) + asin(-y, err)
    else:
        return rational.Rational(math.acos(x))

def asin(x, err=defaultError):
    """

    asin(x [,err]) returns arc sine of x.

    """
    if x > 1 or x < -1:
        raise ValueError, "%s is not in the range [-1, 1]." % str(x)
    if x < 0:
        return -asin(-x)
    if err <= defaultError:
        u = sqrt(rational.Rational(1, 2))
        if x > u:
            return pi(err) / 2 - asin(sqrt(1 - x**2))
        if x == 0:
            return rational.Integer(0)
        y = rational.Rational(x)
        y2 = y ** 2
        i = 2
        retval = y
        term = rational.Rational(y)
        oldvalue = 0
        while err.nearlyEqual(retval, oldvalue):
            oldvalue = +retval
            term *= y2 * (i-1) ** 2 / (i*(i+1))
            i += 2
            retval += term
    else:
        retval = rational.Rational(math.asin(x))
    return retval

def atan(x, err=defaultError):
    """

    atan(x [,err]) returns arc tangent of x.

    """
    if err <= defaultError:
        # atan(x) = -atan(-x)
        if x < 0:
            return -atan(-x, err)
        # atan(x) = pi/2 - atan(1/x)
        elif x > 1:
            return pi(err) / 2 - atan(1 / x, err)
        elif x == 1:
            return pi(err) / 4
        elif x == 0:
            return rational.Integer(0)
        y = rational.Rational(x)
        y2 = y ** 2
        retval = y
        oldvalue = 0
        term = rational.Rational(x)
        i = 1
        while err.nearlyEqual(retval, oldvalue):
            oldvalue = +retval
            i += 2
            term *= -y2 * (i-2) / i
            retval += term
    else:
        retval = rational.Rational(math.atan(x))
    return retval

def atan2(y, x, err=defaultError):
    """

    atan2(x, y [,err]) returns the arc tangent of y/x.
    Unlike atan(y/x), the signs of both x and y are considered.

    It is unrecomended to obtain the value of pi with atan2(0,1).

    """
    if x > 0 and y > 0:
        return atan(x/y)
    elif x > 0 and y < 0:
        return pi(err) * 2 + atan(x/y)
    elif x < 0:
        return pi(err) + atan(x/y)
    elif x == 0 and y > 0:
        return pi(err) / 2
    elif x == 0 and y < 0:
        return -pi(err) / 2
    return rational.Integer(0)

def hypot(x, y, err=defaultError):
    """

    hypot(x, y [,err]) returns sqrt(x**2 + y**2).

    """
    return sqrt(x**2 + y**2, err)

def pow(x, y, err=defaultError):
    """

    x ** y

    """
    if isinstance(y, (int, long)):
        return rational.Rational(x) ** y
    return exp(y * log(x, err), err)

def degrees(rad, err=defaultError):
    """

    converts angle rad from radians to degrees.

    """
    return rad * 180 / pi(err)

def radians(deg, err=defaultError):
    """

    converts angle deg from degrees to radians.

    """
    return deg * pi(err) / 180

def EulerTransform(iterator):
    """

    Return an iterator which yields terms of Euler transform of the
    given iterator.

    """
    stock = []
    b = rational.Rational(1,2)
    l = -1
    for term in iterator:
        stock.append(term)
        for i in xrange(l, -1, -1):
            stock[i] += stock[i+1]
        yield b * stock[0]
        b /= 2
        l += 1

class Constant:
    """

    Constant provides constant-like behavior for Float calculation
    context.  It caches the constant value and re-computes for more
    precision by request.

    example:
    >>> pi = Constant(piGaussLegendre)
    >>> print pi
    3.14159265358979
    >>> pi + 1
    4.14159265358979
    >>> pi(RelativeError(0,1,2**100)) # for 100 bit precision
    3.1415926535897932384626433832795

    """
    def __init__(self, getValue, err=defaultError):
        """

        The first argument must be a function which computes the
        constant with an argument specifies error.
        The second argument can be used to set the default error.

        """
        self.getValue = getValue
        self.err = err
        self.cache = self.getValue(self.err)

    def __call__(self, err):
        """

        Return the value at least as accurate as the given error.

        """
        if self.err < err:
            self.cache = self.getValue(err)
            self.err = err
        return self.cache

    # delegations
    def __add__(self, other):
        return self.cache.__add__(other)

    def __radd__(self, other):
        if isinstance(other, self.cache.__class__):
            return other + self.cache
        else:
            return self.cache.__radd__(other)

    def __sub__(self, other):
        return self.cache.__sub__(other)

    def __rsub__(self, other):
        if isinstance(other, self.cache.__class__):
            return other - self.cache
        else:
            return self.cache.__rsub__(other)

    def __mul__(self, other):
        return self.cache.__mul__(other)

    def __rmul__(self, other):
        if isinstance(other, self.cache.__class__):
            return other * self.cache
        else:
            return self.cache.__rmul__(other)

    def __div__(self, other):
        return self.cache.__div__(other)

    def __rdiv__(self, other):
        if isinstance(other, self.cache.__class__):
            return other / self.cache
        else:
            return self.cache.__rdiv__(other)

    def __truediv__(self, other):
        return self.cache.__truediv__(other)

    def __rtruediv__(self, other):
        if isinstance(other, self.cache.__class__):
            return other / self.cache
        else:
            return self.cache.__rtruediv__(other)

    def __divmod__(self, other):
        return self.cache.__divmod__(other)

    def __rdivmod__(self, other):
        if isinstance(other, self.cache.__class__):
            return divmod(other, self.cache)
        else:
            return self.cache.__rdivmod__(other)

    def __mod__(self, other):
        return self.cache.__mod__(other)

    def __rmod__(self, other):
        if isinstance(other, self.cache.__class__):
            return other % self.cache
        else:
            return self.cache.__rmod__(other)

    def __pos__(self):
        return self.cache.__pos__()

    def __neg__(self):
        return self.cache.__neg__()

    def __abs__(self):
        return self.cache.__neg__()

    def toRational(self):
        return +self.cache

    def inverse(self):
        return self.cache.__rdiv__(rational.Integer(1))

    def __pow__(self, other, dummy=None):
        return self.cache.__pow__(other)

    def __gt__(self, other):
        return self.cache.__gt__(other)

    def __ge__(self, other):
        return self.cache.__ge__(other)

    def __eq__(self, other):
        return self.cache.__eq__(other)

    def __ne__(self, other):
        return self.cache.__ne__(other)

    def __le__(self, other):
        return self.cache.__le__(other)

    def __lt__(self, other):
        return self.cache.__lt__(other)

    def __repr__(self):
        return repr(self.cache)

    def __str__(self):
        return str(self.cache)

    def __getattr__(self, name):
        try:
            return getattr(self.cache, name)
        except:
            raise

pi = Constant(piGaussLegendre)
e = Constant(lambda err: exp(1, err))
Log2 = Constant(lambda err: _log2(err))

theRealField = RealField()
